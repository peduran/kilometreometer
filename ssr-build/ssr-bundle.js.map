{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../node_modules/haversine/haversine.js","webpack:///external \"preact\"","webpack:///../src/index.js","webpack:///./hooks/usePosition.ts","webpack:///../node_modules/fp-ts/es6/function.js","webpack:///../node_modules/fp-ts/es6/Option.js","webpack:///./hooks/useOdometer.ts","webpack:///./components/app.tsx","webpack:///./index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","RADII","toRad","convertCoordinates","haversine","km","mile","meter","nmi","num","Math","PI","format","coordinates","latitude","longitude","lat","lon","lng","geometry","startCoordinates","endCoordinates","options","R","unit","start","end","dLat","dLon","lat1","lat2","a","sin","cos","atan2","sqrt","threshold","require","currentIndex","currentComponent","prevRaf","currentHook","afterPaintEffects","oldBeforeRender","oldAfterDiff","diffed","oldCommit","oldBeforeUnmount","unmount","getHookState","index","type","hooks","length","push","useState","initialState","reducer","init","hookState","_reducer","invokeOrReturn","nextValue","action","setState","useReducer","useEffect","callback","args","state","argsChanged","flushAfterPaintEffects","some","component","forEach","invokeCleanup","invokeEffect","e","vnode","requestAnimationFrame","raf","done","clearTimeout","timeout","HAS_RAF","cancelAnimationFrame","setTimeout","commitQueue","filter","cb","hook","_cleanup","oldArgs","newArgs","arg","f","usePosition","Error","result","setResult","navigator","geolocation","watchId","watchPosition","JSON","stringify","enableHighAccuracy","clearWatch","isNone","fa","_tag","none","useOdometer","totalDistance","updateTotalDistance","previousPositon","updatePreviousPosition","position","ab","bc","cd","de","ef","fg","gh","hi","ij","arguments","pipe","onNone","onSome","prev","distanceIncrement","coords","ma","App","distance","message","max"],"mappings":"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","file":"ssr-bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"QfWi\");\n","var haversine = (function () {\n  var RADII = {\n    km:    6371,\n    mile:  3960,\n    meter: 6371000,\n    nmi:   3440\n  }\n\n  // convert to radians\n  var toRad = function (num) {\n    return num * Math.PI / 180\n  }\n\n  // convert coordinates to standard format based on the passed format option\n  var convertCoordinates = function (format, coordinates) {\n    switch (format) {\n    case '[lat,lon]':\n      return { latitude: coordinates[0], longitude: coordinates[1] }\n    case '[lon,lat]':\n      return { latitude: coordinates[1], longitude: coordinates[0] }\n    case '{lon,lat}':\n      return { latitude: coordinates.lat, longitude: coordinates.lon }\n    case '{lat,lng}':\n      return { latitude: coordinates.lat, longitude: coordinates.lng }\n    case 'geojson':\n      return { latitude: coordinates.geometry.coordinates[1], longitude: coordinates.geometry.coordinates[0] }\n    default:\n      return coordinates\n    }\n  }\n\n  return function haversine (startCoordinates, endCoordinates, options) {\n    options   = options || {}\n\n    var R = options.unit in RADII\n      ? RADII[options.unit]\n      : RADII.km\n\n    var start = convertCoordinates(options.format, startCoordinates)\n    var end = convertCoordinates(options.format, endCoordinates)\n\n    var dLat = toRad(end.latitude - start.latitude)\n    var dLon = toRad(end.longitude - start.longitude)\n    var lat1 = toRad(start.latitude)\n    var lat2 = toRad(end.latitude)\n\n    var a = Math.sin(dLat/2) * Math.sin(dLat/2) +\n            Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2)\n    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))\n\n    if (options.threshold) {\n      return options.threshold > (R * c)\n    }\n\n    return R * c\n  }\n\n})()\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = haversine\n}\n","module.exports = require(\"preact\");","import { options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\thooks._pendingEffects = [];\n\t}\n};\n\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks && c.__hooks._pendingEffects.length) {\n\t\tafterPaint(afterPaintEffects.push(c));\n\t}\n};\n\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\ttry {\n\t\t\tc.__hooks._list.forEach(invokeCleanup);\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {import('./internal').HookState}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\treturn hooks._list[index];\n}\n\n/**\n * @param {import('./index').StateUpdater<any>} initialState\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @param {import('./index').Reducer<any, any>} reducer\n * @param {import('./index').StateUpdater<any>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ any, (state: any) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._component = currentComponent;\n\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst nextValue = hookState._reducer(hookState._value[0], action);\n\t\t\t\tif (hookState._value[0] !== nextValue) {\n\t\t\t\t\thookState._value = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\t}\n\n\treturn hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {any[]} args\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') ref(createHandle());\n\t\t\telse if (ref) ref.current = createHandle();\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @param {() => any} factory\n * @param {any[]} args\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t\treturn (state._value = factory());\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {any[]} args\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(formatter ? formatter(value) : value);\n\t}\n}\n\nexport function useErrorBoundary(cb) {\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = err => {\n\t\t\tif (state._value) state._value(err);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tafterPaintEffects.some(component => {\n\t\tif (component._parentDom) {\n\t\t\ttry {\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t} catch (e) {\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t\toptions._catchError(e, component._vnode);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t});\n\tafterPaintEffects = [];\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeCleanup(hook) {\n\tif (typeof hook._cleanup == 'function') hook._cleanup();\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeEffect(hook) {\n\thook._cleanup = hook._value();\n}\n\n/**\n * @param {any[]} oldArgs\n * @param {any[]} newArgs\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn !oldArgs || newArgs.some((arg, index) => arg !== oldArgs[index]);\n}\n\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n","import { useEffect, useState } from \"preact/hooks\";\n\ntype UsePosition = Error | Position;\nexport const usePosition = (): UsePosition => {\n    const [result, setResult] = useState<UsePosition>(Error(\"loading\"));\n\n    useEffect(() => {\n        const POSITION_OPTIONS = { enableHighAccuracy: true };\n        if (!navigator.geolocation) {\n            setResult(Error(\"Geolocation not available\"));\n            return;\n        }\n\n        const watchId = navigator.geolocation.watchPosition(\n            setResult,\n            e => setResult(Error(JSON.stringify(e))),\n            POSITION_OPTIONS\n        );\n\n        return () => navigator.geolocation.clearWatch(watchId);\n    }, []);\n    return result;\n};\n","/**\n * @since 2.0.0\n */\n/**\n * @since 2.0.0\n */\nexport function identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexport var unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nexport function not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * @since 2.0.0\n */\nexport function constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`\n *\n * @since 2.0.0\n */\nexport var constTrue = function () {\n    return true;\n};\n/**\n * A thunk that returns always `false`\n *\n * @since 2.0.0\n */\nexport var constFalse = function () {\n    return false;\n};\n/**\n * A thunk that returns always `null`\n *\n * @since 2.0.0\n */\nexport var constNull = function () {\n    return null;\n};\n/**\n * A thunk that returns always `undefined`\n *\n * @since 2.0.0\n */\nexport var constUndefined = function () {\n    return;\n};\n/**\n * A thunk that returns always `void`\n *\n * @since 2.0.0\n */\nexport var constVoid = function () {\n    return;\n};\n// TODO: remove in v3\n/**\n * Flips the order of the arguments of a function of two arguments.\n *\n * @since 2.0.0\n */\nexport function flip(f) {\n    return function (b, a) { return f(a, b); };\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nexport function tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nexport function increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nexport function decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nexport function absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/lib/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        case 10:\n            return ij(hi(gh(fg(ef(de(cd(bc(ab(a)))))))));\n    }\n    return;\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport var hole = absurd;\n","import { identity } from './function';\n// -------------------------------------------------------------------------------------\n// guards\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/lib/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport var isSome = function (fa) { return fa._tag === 'Some'; };\n/**\n * Returns `true` if the option is `None`, `false` otherwise\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/lib/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category guards\n * @since 2.0.0\n */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var none = { _tag: 'None' };\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var some = function (a) { return ({ _tag: 'Some', value: a }); };\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function fromNullable(a) {\n    return a == null ? none : some(a);\n}\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? some(a) : none); };\n}\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in\n * `Some`\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/lib/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function tryCatch(f) {\n    try {\n        return some(f());\n    }\n    catch (e) {\n        return none;\n    }\n}\n/**\n * Returns an `E` value if possible\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function getLeft(ma) {\n    return ma._tag === 'Right' ? none : some(ma.left);\n}\n/**\n * Returns an `A` value if possible\n *\n * @category constructors\n * @since 2.0.0\n */\nexport function getRight(ma) {\n    return ma._tag === 'Left' ? none : some(ma.right);\n}\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var fromEither = function (ma) { return (ma._tag === 'Left' ? none : some(ma.right)); };\n// -------------------------------------------------------------------------------------\n// destructors\n// -------------------------------------------------------------------------------------\n/**\n * Takes a default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, fold } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     fold(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function fold(onNone, onSome) {\n    return function (ma) { return (isNone(ma) ? onNone() : onSome(ma.value)); };\n}\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function toNullable(ma) {\n    return isNone(ma) ? null : ma.value;\n}\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport function toUndefined(ma) {\n    return isNone(ma) ? undefined : ma.value;\n}\n/**\n * Less strict version of [`getOrElse`](#getOrElse).\n *\n * @category destructors\n * @since 2.6.0\n */\nexport var getOrElseW = function (onNone) { return function (ma) { return (isNone(ma) ? onNone() : ma.value); }; };\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category destructors\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values\n *\n * @example\n * import { some, none, fromNullable, mapNullable } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     mapNullable(company => company.address),\n *     mapNullable(address => address.street),\n *     mapNullable(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     mapNullable(company => company.address),\n *     mapNullable(address => address.street),\n *     mapNullable(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category combinators\n * @since 2.0.0\n */\nexport function mapNullable(f) {\n    return function (ma) { return (isNone(ma) ? none : fromNullable(f(ma.value))); };\n}\n// -------------------------------------------------------------------------------------\n// non-pipeables\n// -------------------------------------------------------------------------------------\nvar map_ = function (fa, f) { return (isNone(fa) ? none : some(f(fa.value))); };\nvar ap_ = function (fab, fa) { return (isNone(fab) ? none : isNone(fa) ? none : some(fab.value(fa.value))); };\nvar chain_ = function (ma, f) { return (isNone(ma) ? none : f(ma.value)); };\nvar reduce_ = function (fa, b, f) { return (isNone(fa) ? b : f(b, fa.value)); };\nvar foldMap_ = function (M) { return function (fa, f) { return (isNone(fa) ? M.empty : f(fa.value)); }; };\nvar reduceRight_ = function (fa, b, f) { return (isNone(fa) ? b : f(fa.value, b)); };\nvar traverse_ = function (F) { return function (ta, f) {\n    return isNone(ta) ? F.of(none) : F.map(f(ta.value), some);\n}; };\nvar alt_ = function (fa, that) { return (isNone(fa) ? that() : fa); };\nvar filter_ = function (fa, predicate) {\n    return isNone(fa) ? none : predicate(fa.value) ? fa : none;\n};\nvar filterMap_ = function (ma, f) { return (isNone(ma) ? none : f(ma.value)); };\nvar extend_ = function (wa, f) { return (isNone(wa) ? none : some(f(wa))); };\nvar partition_ = function (fa, predicate) {\n    return {\n        left: filter_(fa, function (a) { return !predicate(a); }),\n        right: filter_(fa, predicate)\n    };\n};\nvar partitionMap_ = function (fa, f) { return separate(map_(fa, f)); };\nvar wither_ = function (F) { return function (fa, f) {\n    return isNone(fa) ? F.of(none) : f(fa.value);\n}; };\nvar wilt_ = function (F) { return function (fa, f) {\n    var o = map_(fa, function (a) {\n        return F.map(f(a), function (e) { return ({\n            left: getLeft(e),\n            right: getRight(e)\n        }); });\n    });\n    return isNone(o)\n        ? F.of({\n            left: none,\n            right: none\n        })\n        : o.value;\n}; };\n// -------------------------------------------------------------------------------------\n// pipeables\n// -------------------------------------------------------------------------------------\n/**\n * @category Functor\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) { return map_(fa, f); }; };\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @category Apply\n * @since 2.0.0\n */\nexport var ap = function (fa) { return function (fab) { return ap_(fab, fa); }; };\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @category Apply\n * @since 2.0.0\n */\nexport var apFirst = function (fb) { return function (fa) {\n    return ap_(map_(fa, function (a) { return function () { return a; }; }), fb);\n}; };\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @category Apply\n * @since 2.0.0\n */\nexport var apSecond = function (fb) { return function (fa) {\n    return ap_(map_(fa, function () { return function (b) { return b; }; }), fb);\n}; };\n/**\n * @category Applicative\n * @since 2.7.0\n */\nexport var of = some;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @category Monad\n * @since 2.0.0\n */\nexport var chain = function (f) { return function (ma) { return chain_(ma, f); }; };\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category Monad\n * @since 2.0.0\n */\nexport var chainFirst = function (f) { return function (ma) {\n    return chain_(ma, function (a) { return map_(f(a), function () { return a; }); });\n}; };\n/**\n * @category Monad\n * @since 2.0.0\n */\nexport var flatten = function (mma) { return chain_(mma, identity); };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Option` returns the left-most non-`None` value.\n *\n * @example\n * import * as O from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.alt(() => O.some('b'))\n *   ),\n *   O.some('a')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     O.alt(() => O.some('b'))\n *   ),\n *   O.some('b')\n * )\n *\n * @category Alt\n * @since 2.0.0\n */\nexport var alt = function (that) { return function (fa) { return alt_(fa, that); }; };\n/**\n * @category Alternative\n * @since 2.7.0\n */\nexport var zero = function () { return none; };\n/**\n * @category MonadThrow\n * @since 2.7.0\n */\nexport var throwError = function () { return none; };\n/**\n * @category Extend\n * @since 2.0.0\n */\nexport var duplicate = function (wa) { return extend_(wa, identity); };\n/**\n * @category Extend\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (ma) { return extend_(ma, f); }; };\n/**\n * @category Foldable\n * @since 2.0.0\n */\nexport var foldMap = function (M) {\n    var foldMapM = foldMap_(M);\n    return function (f) { return function (fa) { return foldMapM(fa, f); }; };\n};\n/**\n * @category Foldable\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) { return reduce_(fa, b, f); }; };\n/**\n * @category Foldable\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return reduceRight_(fa, b, f);\n}; };\n/**\n * @category Compactable\n * @since 2.0.0\n */\nexport var compact = flatten;\nvar defaultSeparate = { left: none, right: none };\n/**\n * @category Compactable\n * @since 2.0.0\n */\nexport var separate = function (ma) {\n    var o = map_(ma, function (e) { return ({\n        left: getLeft(e),\n        right: getRight(e)\n    }); });\n    return isNone(o) ? defaultSeparate : o.value;\n};\n/**\n * @category Filterable\n * @since 2.0.0\n */\nexport var filter = function (predicate) { return function (fa) { return filter_(fa, predicate); }; };\n/**\n * @category Filterable\n * @since 2.0.0\n */\nexport var filterMap = function (f) { return function (fa) {\n    return filterMap_(fa, f);\n}; };\n/**\n * @category Filterable\n * @since 2.0.0\n */\nexport var partition = function (predicate) { return function (fa) { return partition_(fa, predicate); }; };\n/**\n * @category Filterable\n * @since 2.0.0\n */\nexport var partitionMap = function (f) { return function (fa) { return partitionMap_(fa, f); }; };\n/**\n * @category Traversable\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseF = traverse_(F);\n    return function (f) { return function (ta) { return traverseF(ta, f); }; };\n};\n/**\n * @category Traversable\n * @since 2.6.3\n */\nexport var sequence = function (F) { return function (ta) {\n    return isNone(ta) ? F.of(none) : F.map(ta.value, some);\n}; };\n/**\n * @category Whitherable\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var witherF = wither_(F);\n    return function (f) { return function (ta) { return witherF(ta, f); }; };\n};\n/**\n * @category Whitherable\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var wiltF = wilt_(F);\n    return function (f) { return function (ta) { return wiltF(ta, f); }; };\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var URI = 'Option';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getShow(S) {\n    return {\n        show: function (ma) { return (isNone(ma) ? 'none' : \"some(\" + S.show(ma.value) + \")\"); }\n    };\n}\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/lib/Option'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * const E = getEq(eqNumber)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getEq(E) {\n    return {\n        equals: function (x, y) { return x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E.equals(x.value, y.value)); }\n    };\n}\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/lib/Option'\n * import { ordNumber } from 'fp-ts/lib/Ord'\n *\n * const O = getOrd(ordNumber)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getOrd(O) {\n    return {\n        equals: getEq(O).equals,\n        compare: function (x, y) { return (x === y ? 0 : isSome(x) ? (isSome(y) ? O.compare(x.value, y.value) : 1) : -1); }\n    };\n}\n/**\n * `Apply` semigroup\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | none               |\n * | none    | some(a) | none               |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getApplySemigroup, some, none } from 'fp-ts/lib/Option'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const S = getApplySemigroup(semigroupSum)\n * assert.deepStrictEqual(S.concat(none, none), none)\n * assert.deepStrictEqual(S.concat(some(1), none), none)\n * assert.deepStrictEqual(S.concat(none, some(1)), none)\n * assert.deepStrictEqual(S.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getApplySemigroup(S) {\n    return {\n        concat: function (x, y) { return (isSome(x) && isSome(y) ? some(S.concat(x.value, y.value)) : none); }\n    };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nexport function getApplyMonoid(M) {\n    return {\n        concat: getApplySemigroup(M).concat,\n        empty: some(M.empty)\n    };\n}\n/**\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/lib/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getFirstMonoid() {\n    return {\n        concat: function (x, y) { return (isNone(x) ? y : x); },\n        empty: none\n    };\n}\n/**\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(a) | some(a)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/lib/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getLastMonoid() {\n    return {\n        concat: function (x, y) { return (isNone(y) ? x : y); },\n        empty: none\n    };\n}\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(a) | some(a)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/lib/Option'\n * import { semigroupSum } from 'fp-ts/lib/Semigroup'\n *\n * const M = getMonoid(semigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport function getMonoid(S) {\n    return {\n        concat: function (x, y) { return (isNone(x) ? y : isNone(y) ? x : some(S.concat(x.value, y.value))); },\n        empty: none\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: map_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: map_,\n    ap: ap_,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: map_,\n    ap: ap_,\n    of: of,\n    chain: chain_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: map_,\n    alt: alt_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: map_,\n    ap: ap_,\n    of: of,\n    alt: alt_,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: map_,\n    extend: extend_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: map_,\n    compact: compact,\n    separate: separate,\n    filter: filter_,\n    filterMap: filterMap_,\n    partition: partition_,\n    partitionMap: partitionMap_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: map_,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_,\n    traverse: traverse_,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: map_,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_,\n    traverse: traverse_,\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: filter_,\n    filterMap: filterMap_,\n    partition: partition_,\n    partitionMap: partitionMap_,\n    wither: wither_,\n    wilt: wilt_\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: map_,\n    ap: ap_,\n    of: of,\n    chain: chain_,\n    throwError: throwError\n};\n// TODO: remove in v3\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var option = {\n    URI: URI,\n    map: map_,\n    of: of,\n    ap: ap_,\n    chain: chain_,\n    reduce: reduce_,\n    foldMap: foldMap_,\n    reduceRight: reduceRight_,\n    traverse: traverse_,\n    sequence: sequence,\n    zero: zero,\n    alt: alt_,\n    extend: extend_,\n    compact: compact,\n    separate: separate,\n    filter: filter_,\n    filterMap: filterMap_,\n    partition: partition_,\n    partitionMap: partitionMap_,\n    wither: wither_,\n    wilt: wilt_,\n    throwError: throwError\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if `ma` contains `a`\n *\n * @example\n * import { some, none, elem } from 'fp-ts/lib/Option'\n * import { eqNumber } from 'fp-ts/lib/Eq'\n *\n * assert.strictEqual(elem(eqNumber)(1, some(1)), true)\n * assert.strictEqual(elem(eqNumber)(2, some(1)), false)\n * assert.strictEqual(elem(eqNumber)(1, none), false)\n *\n * @since 2.0.0\n */\nexport function elem(E) {\n    return function (a, ma) { return (isNone(ma) ? false : E.equals(a, ma.value)); };\n}\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/lib/Option'\n * import { pipe } from 'fp-ts/lib/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\nexport function exists(predicate) {\n    return function (ma) { return (isNone(ma) ? false : predicate(ma.value)); };\n}\n/**\n * Returns a `Refinement` (i.e. a custom type guard) from a `Option` returning function.\n * This function ensures that a custom type guard definition is type-safe.\n *\n * ```ts\n * import { some, none, getRefinement } from 'fp-ts/lib/Option'\n *\n * type A = { type: 'A' }\n * type B = { type: 'B' }\n * type C = A | B\n *\n * const isA = (c: C): c is A => c.type === 'B' // <= typo but typescript doesn't complain\n * const isA = getRefinement<C, A>(c => (c.type === 'B' ? some(c) : none)) // static error: Type '\"B\"' is not assignable to type '\"A\"'\n * ```\n *\n * @since 2.0.0\n */\nexport function getRefinement(getOption) {\n    return function (a) { return isSome(getOption(a)); };\n}\n","import { pipe } from \"fp-ts/es6/function\";\nimport { fold, none, Option, some } from \"fp-ts/es6/Option\";\nimport haversine from \"haversine\";\nimport { useState, useEffect } from \"preact/hooks\";\nimport { usePosition } from \"./usePosition\";\n\nexport const useOdometer = () => {\n    const [totalDistance, updateTotalDistance] = useState(0);\n    const [previousPositon, updatePreviousPosition] = useState<\n        Option<Position>\n    >(none);\n    const position = usePosition();\n    useEffect(() => {\n        if (!(position instanceof Error)) {\n            return pipe(\n                previousPositon,\n                fold(\n                    () => {\n                        updatePreviousPosition(some(position));\n                    },\n                    prev => {\n                        const distanceIncrement = haversine(\n                            {\n                                latitude: position.coords.latitude,\n                                longitude: position.coords.longitude\n                            },\n                            {\n                                latitude: prev.coords.latitude,\n                                longitude: prev.coords.longitude\n                            }\n                        );\n                        updateTotalDistance(distanceIncrement + totalDistance);\n                    }\n                )\n            );\n        }\n    }, [position]);\n    return totalDistance;\n};\n","import { FunctionalComponent, h } from \"preact\";\nimport { usePosition } from \"../hooks/usePosition\";\nimport { useOdometer } from \"../hooks/useOdometer\";\n\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nif ((module as any).hot) {\n    // tslint:disable-next-line:no-var-requires\n    require(\"preact/debug\");\n}\n\nconst App: FunctionalComponent = () => {\n    const position = usePosition()\n    const distance = useOdometer()\n    return (\n        <div>\n            <h1>Kilometreomter</h1>\n            {position instanceof Error ?\n                <pre>{position.message}</pre> :\n                <pre>{position.coords.latitude} {position.coords.longitude} </pre>\n            }\n            {distance} km\n            <meter max=\"1\" value={distance} />\n        </div>\n    );\n};\n\nexport default App;\n","import \"./style/index.css\";\nimport App from \"./components/app.tsx\";\n\nexport default App;\n"],"sourceRoot":""}